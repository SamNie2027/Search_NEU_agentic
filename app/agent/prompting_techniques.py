"""
ReAct Prompting Techniques.

Provides functions for parsing agent actions, formatting agent history,
and constructing prompts for the ReAct (Reasoning and Acting) agent framework.
"""
import json
from typing import Any, Dict, List, Optional, Tuple
import ast
import re
import textwrap
import csv, io


# The prompt for a language model in a ReAct framework is in the following format
#     "User prompt: 'Who painted The Starry Night and where was it painted?' "
#     "Thought: I should search for key facts about the painting"
#     "Action: search[query="starry night", k=3]"
#     "Observation: {"results": [{"title": "The Starry Night"}]}"
#
#     The thought and action will be generated by a language model
#     The observation would be the returned results from the search method we defined above
#     We will implement to interleave the language model with external tools (e.g., the search method)


def convert_value(raw: str) -> Any:
    """
    Convert a raw string token into a Python type:
      - quoted strings -> str
      - numbers -> int or float
      - true/false -> bool
      - otherwise -> original string (stripped)
    Uses ast.literal_eval for safety (no code execution).
    """
    raw = raw.strip()
    # Normalize JSON-like booleans
    if raw.lower() == "true":  return True
    if raw.lower() == "false": return False
    try:
        # Handles "..." / '...' / 123 / 4.5
        return ast.literal_eval(raw)
    except Exception:
        # Fallback: unquoted, non-numeric tokens
        return raw.strip('"').strip("'")

def split_args(argstr: str) -> Dict[str, Any]:
    """
    This function splits the string such as 'k=3, query="starry night"' into a dictionary {'k':3, 'query':'starry night'},
    Note: relies on double quotes to protect commas inside strings.
    """
    args: Dict[str, Any] = {}
    row = next(csv.reader(io.StringIO(argstr), delimiter=",", skipinitialspace=True, quotechar='"'), [])
    for field in row:
        field = field.strip()
        if not field:
            continue
        if "=" in field:
            key, val = field.split("=", 1)
            args[key.strip()] = convert_value(val)
        else:
            # bare flag -> True
            args[field] = True
    return args


def parse_action(line: str) -> Optional[Tuple[str, Dict[str, Any]]]:
    """
    Parse lines like:
      Action: search[query="van gogh starry night", k=3]
      Action: finish[answer="Vincent van Gogh."]
    Returns (action_name, args_dict) or None on invalid input.
    """
    # Use the `split_args` helper to convert the bracket contents into args.
    # Expected format after trimming:
    #   Action: name[key="value", k=3]
    line = line.strip()
    if not line.startswith("Action:"):
        return None

    rest = line[len("Action:"):].strip()

    # Regex to capture: name[...]
    # Require only lowercase letters and underscores for the name, no spaces.
    m = re.match(r"^([a-z_]+)\[(.*)\]$", rest)
    if not m:
        # invalid format (missing brackets or invalid name)
        return None

    name = m.group(1)
    args_str = m.group(2).strip()

    # Basic name sanity-check: only lowercase letters and underscores
    if not re.fullmatch(r"[a-z_]+", name):
        return None

    # Parse args (may be empty)
    if not args_str:
        args = {}
    else:
        try:
            args = split_args(args_str)
        except Exception:
            return None

    return name, args


def format_history(trajectory: List[Dict[str, str]]) -> str:
    """
    Each step in trajectory should have keys: 'thought', 'action', 'observation'.
    We render them in the canonical ReAct order for the next prompt.
    """
    lines: List[str] = []
    for step in trajectory:
        lines.append(f"Thought: {step['thought']}")
        lines.append(f"Action: {step['action']}")
        lines.append(f"Observation: {step['observation']}")
    return "\n".join(lines)

subject_codes = {
    "MGT": "Management - CPS",
    "EDUT": "Education - California Prepared",
    "ENVR": "Earth and Environmental Sciences",
    "PST": "Professional Studies - CPS",
    "AMSL": "American Sign Language",
    "ANTH": "Anthropology",
    "CSYE": "Computer Systems Engineering",
    "DA": "Data Analytics",
    "SBSY": "Sustainable Building Systems",
    "LING": "Linguistics",
    "GE": "General Engineering",
    "PHMD": "Pharmacy Practice",
    "HONR": "Honors Program",
    "PJM": "Project Management - CPS",
    "DS": "Data Science",
    "INSC": "Interdisciplinary Studies in Science",
    "HRM": "Human Resources Management - CPS",
    "FRNH": "French",
    "EMGT": "Engineering Management",
    "DEAF": "Deaf Studies",
    "STRT": "Strategy",
    "NNMD": "Nanomedicine",
    "ECN": "Economics - CPS",
    "PHL": "Philosophy - PHL",
    "PHLS": "Philosophy - CPS Specialty",
    "BNSC": "Behavioral Neuroscience",
    "SPNS": "Spanish",
    "SLPA": "Speech-Language Pathology and Audiology",
    "ENGW": "English Writing",
    "BUSN": "Business Administration",
    "JRNL": "Journalism",
    "ENLR": "Engineering Leadership",
    "EEAM": "Co-op/Experiential Education in Arts, Media, and Design",
    "MISM": "Management Information Systems",
    "HINF": "Health Informatics",
    "BIOE": "Bioengineering",
    "HSCI": "Health Science",
    "EESH": "Co-op/Experiential Education in Social Sciences and Humanities",
    "OR": "Operations Research",
    "GAME": "Game Design",
    "LW": "Law (for Non-Law School Students)",
    "CY": "Cybersecurity",
    "EDUC": "Education",
    "PMST": "Pharmaceutics",
    "AAI": "Applied Artificial Intelligence - CPS",
    "ACCT": "Accounting",
    "THTR": "Theatre",
    "NRSG": "Nursing",
    "EXRE": "Extended Realities",
    "ACC": "Accounting - CPS",
    "WMNS": "Women’s, Gender, and Sexuality Studies",
    "PHY": "Physics - CPS",
    "CHM": "Chemistry - CPS",
    "MKT": "Marketing - CPS",
    "MUST": "Music Technology",
    "IE": "Industrial Engineering",
    "ARTF": "Art - Fundamentals",
    "PSY": "Psychology - CPS",
    "ENGL": "English",
    "DADS": "Data Analytics and Decision Support",
    "INSH": "Interdisciplinary Studies in Social Sciences and Humanities",
    "EEBA": "Co-op/Experiential Education in Business",
    "EEMB": "Ecology, Evolution, and Marine Biology",
    "MGSC": "Management Science",
    "INNO": "Corporate Innovation",
    "CHNS": "Chinese",
    "ARTD": "Art - Media Arts",
    "MSCI": "Medical Sciences",
    "AACE": "Arts Administration and Cultural Entrepreneurship",
    "TELR": "Technology Leadership",
    "ABRS": "Study Abroad - Science",
    "KORE": "Korean",
    "ARTG": "Art - Design",
    "AVM": "Advanced Manufacturing Systems - CPS",
    "LACS": "Latin American and Caribbean Studies",
    "MTH": "Mathematics - CPS",
    "NETS": "Network Science",
    "MUSC": "Music",
    "CRIM": "Criminal Justice",
    "ARCH": "Architecture",
    "INT": "Interdisciplinary Studies - CPS",
    "HSV": "Human Services - CPS",
    "GBST": "Global Studies",
    "CIVE": "Civil and Environmental Engineering",
    "SOCL": "Sociology",
    "BTC": "Biotechnology - CPS",
    "SMFA": "School of the Museum of Fine Arts",
    "EESC": "Co-op/Experiential Education in Science",
    "ENCP": "Engineering Co-Op Education",
    "HMG": "Health Management - CPS",
    "GSND": "Game Science and Design",
    "ME": "Mechanical Engineering",
    "LST": "Liberal Studies - CPS",
    "TELE": "Telecommunication Systems",
    "LS": "Legal Studies",
    "FIN": "Finance - CPS",
    "ENVS": "Environmental Studies",
    "PHYS": "Physics",
    "ALY": "Analytics - CPS",
    "GRMN": "German",
    "COMM": "Communication Studies",
    "EXED": "Cooperative/Experiential Education",
    "LPSC": "Law and Public Policy",
    "INAM": "Interdisciplinary Studies in Arts, Media, and Design",
    "BINF": "Bioinformatics",
    "BIOT": "Biotechnology",
    "LDR": "Leadership Studies - CPS",
    "ESLG": "English as a Second Language - CPS Specialty",
    "TCC": "Technical Communications - CPS",
    "ARTS": "Art - Studio",
    "ARTH": "Art - History",
    "SCHM": "Supply Chain Management",
    "PHIL": "Philosophy",
    "RSSN": "Russian",
    "JPNS": "Japanese",
    "SUEN": "Sustainable Urban Environments",
    "GET": "General Engineering Technology - CPS",
    "INTL": "International Affairs",
    "INFO": "Information Systems Program",
    "ASNS": "Asian Studies",
    "PHTH": "Public Health",
    "POL": "Political Science - CPS",
    "ENG": "Political Science - CPS",
    "BIOC": "Biochemistry",
    "MECN": "Managerial Economics",
    "CHEM": "Chemistry and Chemical Biology",
    "MSCR": "Media and Screen Studies",
    "CHME": "Chemical Engineering",
    "MET": "Mechanical Engineering Technology - CPS",
    "ITC": "Information Technology - CPS",
    "EET": "Electrical Engineering Technology - CPS",
    "INMI": "Interdisciplinary Studies - Mills College at Northeastern",
    "EECE": "Electrical and Computer Engineering",
    "HSTY": "History - CPS Specialty",
    "BIOL": "Biology",
    "PMCL": "Pharmacology",
    "HLTH": "Health Science - Interdisciplinary",
    "MATH": "Mathematics",
    "ORGB": "Organizational Behavior",
    "EXSC": "Cardiopulmonary and Exercise Science",
    "SOC": "Sociology - CPS",
    "MEIE": "Mechanical and Industrial Engineering",
    "FINA": "Finance and Insurance",
    "ARAB": "Arabic",
    "HUSV": "Arabic",
    "CLTR": "Culture",
    "CS": "Computer Science",
    "MATL": "Materials Engineering",
    "PORT": "Portuguese",
    "CMN": "Communication Studies - CPS",
    "HBRW": "Communication Studies - CPS",
    "INTB": "International Business",
    "HSC": "Health Science - CPS",
    "DAMG": "Data Architecture Management",
    "BIO": "Biology - CPS",
    "AFCS": "Africana Studies",
    "PA": "Physician Assistant",
    "PREL": "Public Relations",
    "PSYC": "Psychology",
    "LARC": "Landscape Architecture",
    "INPR": "Interdisciplinary Studies - Office of the Provost",
    "PT": "Physical Therapy",
    "PDM": "Product Management - CPS",
    "CET": "Computer Engineering Technology - CPS",
    "HIST": "History",
    "MUSI": "Music Industry",
    "ENTR": "Entrepreneurship and Innovation",
    "JWSS": "Jewish Studies",
    "FSEM": "First-Year Seminar",
    "ENGR": "Engineering Interdisciplinary",
    "PHDL": "PhD Experiential Leadership",
    "CAEP": "Counseling and Applied Educational Psychology",
    "CRWT": "Creative Writing",
    "ARMY": "Army ROTC",
    "LAW": "Law",
    "ITLN": "Italian",
    "POLS": "Political Science",
    "MKTG": "Marketing",
    "ENSY": "Energy Systems",
    "ECON": "Economics",
    "PPUA": "Public Policy and Urban Affairs",
    "PHSC": "Pharmaceutical Science",
    "HRMG": "Human Resources Management",
    "MGMT": "Management"
}

bucket_levels = {
    1000: "Introductory level (first year), for students with no prior background",
    2000: "Intermediate level (first/sophomore/junior year) includes more rigorous introductory courses and next level courses",
    3000: "Upper-intermediate level (junior year)",
    4000: "Advanced level (senior year)",
    5000: "First-level graduate",
    6000: "Second-level graduate (Generally for master’s and clinical doctorate only)",
    7000: "Third-level graduate (Master’s- and doctoral-level courses; includes master’s thesis)",
    8000: "Clinical/research/readings",
    9000: "Doctoral research and dissertation"
}


SYSTEM_PREAMBLE_WITH_FILTERS = f"""
    You are a helpful ReAct agent. You may use tools to find relevant courses for the user.

    Note: The College of Professional Studies, aka CPS program is separate from Undergraduate/Graduate courses so avoid recommending unless the query or context includes CPS.
    
    Available subject codes (subject parameter for keyword_search) can ONLY assign subject to these:
    {json.dumps(subject_codes, indent=2)}

    Available bucket levels (Most relevant will be 2000, 3000, or 4000. Please add more weight to those):
    {json.dumps(bucket_levels, indent=2)}

    When the user requests information related to a subject, choose the most appropriate subject code.
    If uncertain, choose the subject whose full name best matches the user’s query. 

    Available tools (examples show optional params):
    - keyword_search[query="<text>"]
    - keyword_search[query="<text>", bucketLevel=<bucketLevel>]
    - keyword_search[query="<text>", subject="<subject code>"]
    - keyword_search[query="<text>", bucketLevel=<bucketLevel>, subject="<subject code>"]
    - semantic_search[query="<text>"]

    Guidance on tool choice:
    - Use `keyword_search` when the user supplies queries that search on all words as keywords without semantic meaning. Best to provide as many keywords as possible.
    - Use `semantic_search` when the user query is a longer natural-language sentence, question, or contains conversational context.
    The agent may decide which tool to use based on the query; prefer semantic_search for verbose queries and keyword_search for concise ones.

    Examples (produce EXACTLY two lines in these formats):
    Example 1 (keyword search):
    Thought: I should search for the course by keyword to find the description
    Action: keyword_search[query="Object Oriented Programming", subjectCode="CS", bucketLevel="3000" k=3]

    Example 2 (semantic search):
    Thought: The user's question is conversational; use semantic search for context.
    Action: semantic_search[query="I'm looking to learn about Programming Patterns and Object Oriented Programming", k=3]

    IMPORTANT: Only output exactly two lines for every response. Do NOT include extra commentary, numbered lists, or additional text. Follow the formats above strictly.

        To finish, use: finish[answer="<final answer>"]

        Follow the exact step format (showing optional params explicitly):
        Thought: <your reasoning>
        Action: keyword_search[query="<text>", bucketLevel=<optional integer>, subject="<optional subject code>"]
            or semantic_search[query="<text>"]
            or finish[answer="<final answer>"]
""".strip()

SYSTEM_PREAMBLE_NO_FILTERS = f"""
    You are a helpful ReAct agent. You may use tools to find relevant courses for the user. DO NOT use bucketLevel or subject filters.

    Available tools:
    - keyword_search[query="<text>"]
    - semantic_search[query="<text>"]

    Guidance on tool choice:
    - Use `keyword_search` when the user supplies queries that search on all words as keywords without semantic meaning. Best to provide as many keywords as possible.
    - Use `semantic_search` when the user query is a longer natural-language sentence, question, or contains conversational context. 
    The agent may decide which tool to use based on the query; prefer semantic_search for verbose queries and keyword_search for concise ones.

    IMPORTANT: Only output exactly two lines for every response. Do NOT include extra commentary, numbered lists, or additional text. Follow the formats above strictly.

        To finish, use: finish[answer="<final answer>"]

        Follow the exact step format (showing optional params explicitly):
        Thought: <your reasoning>
        Action: keyword_search[query="<text>", k=3]
            or semantic_search[query="<text>", k=3]
            or finish[answer="<final answer>"]
""".strip()


def make_prompt(user_query: str, trajectory: List[Dict[str, str]], useFilters: bool = True) -> str:
    """
    Construct the model prompt by concatenating:
      (1) a clear system preamble with the tool contract,
      (2) the user question,
      (3) the formatted history so far,
      (4) a cue to produce the next Thought.
    """
    # If filters are disabled, sanitize any previous Action lines so that
    # bucketLevel/subject arguments are not present in the prompt history.
    def _remove_filters_from_args(argstr: str) -> str:
        # Remove bucketLevel and subject assignments (handle quoted or unquoted values)
        argstr = re.sub(r"\s*,\s*bucketLevel\s*=\s*(?:\"[^\"]*\"|'[^']*'|[^,\]]+)", "", argstr)
        argstr = re.sub(r"\s*,\s*subject\s*=\s*(?:\"[^\"]*\"|'[^']*'|[^,\]]+)", "", argstr)
        # Trim leading/trailing commas and whitespace left behind
        argstr = re.sub(r"^\s*,\s*", "", argstr)
        argstr = re.sub(r"\s*,\s*$", "", argstr)
        return argstr

    if useFilters:
        history_block = format_history(trajectory)
        preamble = SYSTEM_PREAMBLE_WITH_FILTERS
    else:
        # Build a sanitized trajectory where any bucket/subject args are stripped
        sanitized: List[Dict[str, str]] = []
        for step in trajectory:
            action = step.get("action", "")
            # Try to parse Action: name[...] and strip disallowed args
            m = re.match(r"Action:\s*([a-z_]+)\[(.*)\]$", action)
            if m:
                name = m.group(1)
                args = m.group(2)
                cleaned = _remove_filters_from_args(args)
                # Keep empty brackets when there are no args left (consistent formatting)
                action_sanit = f"Action: {name}[{cleaned}]"
            else:
                action_sanit = action
            sanitized.append({"thought": step.get("thought", ""), "action": action_sanit, "observation": step.get("observation", "")})

        history_block = format_history(sanitized)
        preamble = SYSTEM_PREAMBLE_NO_FILTERS

    return (
        f"{preamble}\n\n"
        f"User Question: {user_query}\n\n"
        f"{history_block}\n"
        f"Next step:\n"
        f"Thought:"
    )